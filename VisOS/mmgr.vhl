#include "VisOS.Driver/cout.vhl"
#include "VisOS.Driver/cmgr.vhl"
#include "utils/error_handler.vhl"

uint MANAGED_END;
uint MAX_ALLOCATIONS;
uint MANAGED_START;

uint CUR_ALLOCS;
uint CUR_ALLOC_TABLE_START = 0x1FFFE;
uint CUR_START;


//Debug Strings
uint ENABLE_DEBUG = 0;
string(TXT_DEBUG_TAG, "[MMGR] ");
string(TXT_CURRENT_ALLOCS, "Current Allocations: ");
string(TXT_DEALLOC, "Deallocating: ");
string(TXT_ALLOC, "Allocating: ");
string(TXT_ALLOC_SIZE, "Size: ");

string(ERR_OUT_OF_MEM, "Out of Memory Error.");

string(INIT_MSTART, "Managed Start: ");
string(INIT_MEND, "Managed End: ");
string(INIT_MAXALLOC, "Max Allocations: ");
string(INIT_TSTART, "Allocation Table Start: ");
string(INIT_CUR_START, "Allocation Store Start: ");


public void MMGR_ToggleDebug(uint enable)
{
	ENABLE_DEBUG = enable;
	return;
}

public uint MMGR_AllocCount()
{
	return CUR_ALLOCS;
}


private void WriteDebugString(uint ptr, uint size)
{
	if(ENABLE_DEBUG)
	{
		uint lastFore = CMGR_GetForeColor();
		CMGR_SetForeColor(12);
		COUT_WriteString(ptr, size);
		CMGR_SetForeColor(lastFore);
	}
	return;
}

private void WriteDebugLine(uint ptr, uint size)
{
	if(ENABLE_DEBUG)
	{
		uint lastFore = CMGR_GetForeColor();
		CMGR_SetForeColor(12);
		COUT_WriteLine(ptr, size);
		CMGR_SetForeColor(lastFore);
	}
	return;
}

private void WriteDebugNum(uint num)
{
	if(ENABLE_DEBUG)
	{
		uint lastFore = CMGR_GetForeColor();
		CMGR_SetForeColor(12);
		COUT_WriteNumber(num);
		CMGR_SetForeColor(lastFore);
	}
	return;
}

private void WriteDebugNewLine()
{
	if(ENABLE_DEBUG)
	{
		uint lastFore = CMGR_GetForeColor();
		CMGR_SetForeColor(12);
		COUT_WriteNewLine();
		CMGR_SetForeColor(lastFore);
	}
	return;
}
private void WriteDebugAllocCount()
{
	WriteDebugString(&TXT_DEBUG_TAG, size_of(TXT_DEBUG_TAG));
	WriteDebugString(&TXT_CURRENT_ALLOCS, size_of(TXT_CURRENT_ALLOCS));
	WriteDebugNum(CUR_ALLOCS);
	WriteDebugNewLine();
	return;
}

private void WriteAllocData(uint index, uint ptr, uint len)
{	
	uint idxPtr = index * 2;

	CUR_ALLOC_TABLE_START[idxPtr] = ptr;
	CUR_ALLOC_TABLE_START[idxPtr+1] = len;

	return;
}

private void EraseAllocData(uint index)
{	
	uint idxPtr = index * 2;

	CUR_ALLOC_TABLE_START[idxPtr] = 0;
	CUR_ALLOC_TABLE_START[idxPtr+1] = 0;


	return;
}

public void MMGR_Free(uint ptr)
{
	if(!ptr)
	{
		return;
	}
	uint i = 0;
	while(i < MAX_ALLOCATIONS)
	{
		uint idx = i * 2;
		uint entry = CUR_ALLOC_TABLE_START[idx];

		if(ptr == entry)
		{
			WriteDebugString(&TXT_DEBUG_TAG, size_of(TXT_DEBUG_TAG));
			WriteDebugString(&TXT_DEALLOC, size_of(TXT_DEALLOC));
			WriteDebugNum(entry);
			WriteDebugNewLine();

			WriteDebugString(&TXT_DEBUG_TAG, size_of(TXT_DEBUG_TAG));
			WriteDebugString(&TXT_ALLOC_SIZE, size_of(TXT_ALLOC_SIZE));
			
			uint size=CUR_ALLOC_TABLE_START[idx+1];
			WriteDebugNum(size);
			WriteDebugNewLine();
			EraseAllocData(i);

			CUR_ALLOCS--;
			return;
		}
		i++;
	}
	return;
}


public uint MMGR_GetPtrSize(uint ptr)
{
	if(!ptr)
	{
		return 0;
	}
	uint i = 0;
	while(i < MAX_ALLOCATIONS)
	{
		uint idx = i * 2;
		uint entry = CUR_ALLOC_TABLE_START[idx];

		if(ptr == entry)
		{
			return CUR_ALLOC_TABLE_START[idx+1];
		}
		i++;
	}
	return 0;
}

public uint MMGR_IsPtr(uint ptr)
{
	if(!ptr)
	{
		return 0;
	}
	uint i = 0;
	while(i < MAX_ALLOCATIONS)
	{
		uint idx = i * 2;
		uint entry = CUR_ALLOC_TABLE_START[idx];

		if(ptr == entry)
		{
			return 1;
		}
		i++;
	}
	return 0;
}

public uint MMGR_Alloc(uint size)
{
	uint cur = CUR_START;
	uint end = cur + size;
	if(end > MANAGED_END)
	{

		_ERROR_T(&ERR_OUT_OF_MEM, size_of(ERR_OUT_OF_MEM));
		
		return;
	}
	WriteAllocData(CUR_ALLOCS, cur, size);
	CUR_ALLOCS++;

	WriteDebugString(&TXT_DEBUG_TAG, size_of(TXT_DEBUG_TAG));
	WriteDebugString(&TXT_ALLOC, size_of(TXT_ALLOC));
	WriteDebugNum(cur);
	WriteDebugNewLine();
	
	WriteDebugString(&TXT_DEBUG_TAG, size_of(TXT_DEBUG_TAG));
	WriteDebugString(&TXT_ALLOC_SIZE, size_of(TXT_ALLOC_SIZE));
	WriteDebugNum(size);
	WriteDebugNewLine();
	WriteDebugAllocCount();

	CUR_START += size;
	return cur;
}


public void MMGR_Initialize()
{
	MANAGED_END = 0x3FFFC;
	MAX_ALLOCATIONS = 0x1000;
	MANAGED_START = 0x1FFFE;
	CUR_ALLOCS = 0;
	CUR_ALLOC_TABLE_START = MANAGED_START;
	CUR_START = MANAGED_START + MAX_ALLOCATIONS * 2;

	WriteDebugString(&TXT_DEBUG_TAG, size_of(TXT_DEBUG_TAG));
	WriteDebugString(&INIT_MSTART, size_of(INIT_MSTART));
	WriteDebugNum(MANAGED_START);
	WriteDebugNewLine();

	WriteDebugString(&TXT_DEBUG_TAG, size_of(TXT_DEBUG_TAG));
	WriteDebugString(&INIT_MEND, size_of(INIT_MEND));
	WriteDebugNum(MANAGED_END);
	WriteDebugNewLine();

	WriteDebugString(&TXT_DEBUG_TAG, size_of(TXT_DEBUG_TAG));
	WriteDebugString(&INIT_MAXALLOC, size_of(INIT_MAXALLOC));
	WriteDebugNum(MAX_ALLOCATIONS);
	WriteDebugNewLine();

	WriteDebugString(&TXT_DEBUG_TAG, size_of(TXT_DEBUG_TAG));
	WriteDebugString(&INIT_TSTART, size_of(INIT_TSTART));
	WriteDebugNum(CUR_ALLOC_TABLE_START);
	WriteDebugNewLine();

	WriteDebugString(&TXT_DEBUG_TAG, size_of(TXT_DEBUG_TAG));
	WriteDebugString(&INIT_CUR_START, size_of(INIT_CUR_START));
	WriteDebugNum(CUR_START);
	WriteDebugNewLine();

	
	return;
}